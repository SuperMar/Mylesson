C++没有多维数组,通常所说的多维数组其实是数组的数组

int ia[3][4]  //大小为3的数组, 每个元素是含有4个整数的数组, 对于二维数组, 第一个维度称作行, 第二个维度称作列
int arr[10][20][30] = {0};  //大小为10的数组,它的每个元素都是大小为20的数组,这些数组的元素是含有30个整数的数组,将所有元素初始化为0

int ia[3][4] = {      //内层花括号并非必须
  {0, 1, 2, 3},
  {4, 5, 6, 7},
  {8, 9, 10, 11}
};

int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

int ia[3][4] = {{ 0 }, { 4 }, { 8 }};   //仅初始化每一行的第一个元素,其他执行默认值初始化

ia[2][3] = arr[0][0][0];   //用arr的首元素为ia的最后一行的最后一个元素赋值
int (&row)[4] = ia[1];     //把row绑定到ia的第二个4元素数组上

constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];    //12个未初始化的元素
for (size_t i = 0; i != rowCnt; ++i) {
    //对于行内的每一列
    for(size_t j = 0; j != colCnt; ++j){
        //将元素的位置索引作为它的值
        ia[i][j] = i * colCnt + j;
  }
}

范围for语句实现上述程序:
size_t cnt = 0;
for (auto &row : ia)
    for (auto &col : row) {
        col = cnt;
        ++cnt;
}

注:<1> for (const auto &row : ia)
        for (auto col : row)
            cout << col << endl;
            
  <2> for (auto row : ia)
          for (auto col : row)
          
<1>循环中没有任何写操作,还是将外层循环的控制变量声明成了引用类型,这是为了避免数组被自动转成指针
<2>程序无法通过编译,第一个循环遍历ia所有元素,这些元素实际上是大小为4的数组,因为row不是引用类型,所以编译器初始化row时会自动将这些数组形式的元素
   转换成指向该数组内首元素的指针,这样得到的row的类型就是int*,内层循环不合法
注:要使用范围for语句处理多维数组,除了最内层的循环外,其他所有循环控制变量都应该是引用类型

注:定义指向多维数组的指针时,这个多维数组实际上是数组的数组,所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针
int ia[3][4];
int (*p)[4] = ia;    //p指向含有4个整数的数组,int *p[4] 整型数组的指针
p = &ia[2];          //p指向ia的尾元素

类型别名简化多维数组的指针:
using int_array = int[4];
typedef int int_array[4];
