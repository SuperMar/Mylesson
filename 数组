数组也是存放类型相同的对象的容器,数组的大小确定不变，不能随意向数组中增加元素
a[d]  a是数组的名字,d是数组的维度，维度说明了数组中元素的个数，因此必须大于0,维度必须是一个常量表达式,可以对数组的元素进行列表初始化,此时允许忽略数组的维度
数组中元素的个数也属于数组类型的一部分,编译的时候应该是已知的
默认情况下,数组的元素被默认初始化
定义数组的时候必须指定数组的类型,不允许用auto关键字由初始值的列表推断类型
和vector一样,数组的元素应为对象,因此不存在引用的数组

字符数组有一种额外的初始化形式,我们可以使用字符串字面值对此类数组初始化,使用这种方式时,一定要注意字符串结尾处还有一个空字符,这个空字符也会像其他字符一样被拷贝到字符数组中去
例:char a1[] = {'C', '+', '+'};           a1的维度为3
  char a2[] = {'C', '+', '+', '\0'};      a2的维度为4
  char a3[] = "C++";                      a3的维度为4
  const char a4[6] = "Daniel";            错误:没有空间可存放空字符
  
不允许拷贝和赋值:
例:int a2[] = a;       //错误
   a2 = a;            //错误

数组能存放大多数类型的对象,因为数组本身就是对象,所以允许定义数组的指针及数组的引用:
例: int *ptrs[10];                //ptrs是含有10个整型指针的数组(类型修饰符从右向左依次绑定)
   int &refs[10] = /* ? */;      //错误,不存在引用的数组
   int (*Parray)[10] = &arr;     //Parray指向一个含有10个整数的数组
   int (&arrRef)[10] = arr;      //arrRef引用一个含有10个整数的数组
   
数组下标的类型size_t,size_t是一种机器相关的无符号类型

数组下标越界(大于0小于数组的大小)可以通过编译,大多数常见的安全问题都源于缓冲区溢出错误,当数组或其他类似数据结构的下标越界并试图访问非法内存区域时,就会产生此类错误

使用数组的时候,编译器一般会把它转换成指针,使用数组类型的对象其实是使用一个指向该数组首元素的指针
string *p2 = nums;   等价于p2 = &nums[0]

指针也是迭代器

数组不是类,没有成员函数begin和end,标准库提供函数begin和end
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int *beg = begin(ia);                 //指向ia首元素的指针
int *last = end(ia);                  //指向arr尾元素的下一位置的指针
