一元运算符 二元运算符 三元运算符 函数调用也是一种特殊的运算符，它对运算对象的数量没有限制
对于含有多个运算符的复杂表达式来说,要想理解它的含义首先要理解运算符的优先级,结合律,以及运算对象的求值顺序
一般的二元运算符要求两个运算对象相同,运算对象转换
重载运算符运算对象的类型和返回值的类型由运算符定义,但运算对象的个数,运算符的优先级和结合律无法改变
当一个对象被用作右值的时候,用的是对象的值(内容),当对象被用作左值的时候,用的是对象的身份(在内存中的位置)
假设p的类型是int*,因为解引用运算符生成左值,所以decltype(*p)的结果是int&,另一方面,因为取地址运算符生成右值,所有decltype(&p)的结果是int**
f()+g()*h()+j(),对于这些函数的调用顺序没有明确规定,如果f,g,h,j是无关函数，它们既不会改变同一对象的状态也不执行IO任务,那么函数的调用顺序不受限制
一元负号运算符对运算对象值取负后,返回其提升后的副本:
bool b = true;
bool b2 = -b;      //b2的值为true

%俗称取余或取模运算符,参与取余运算的运算对象必须是整数类型

因为关系运算符的求值结果是布尔值,所以将几个关系运算符连写在一起会产生意想不到的效果: if (i < j < k) 若k大于1则为真
所以应写成:if (i < j && j < k)

if(val)  if(!val) 编译器会将val转换成布尔值
if(val == true) 如果val不是布尔值,这样的比较将失去意义

赋值预算符的结果是它的左侧运算对象,并且是一个左值,结果的类型就是左侧运算对象的类型,如果赋值运算符左右两个运算对象类型不同,则右侧对象将转换成左侧运算对象的类型

如果左侧运算对象是内置类型,那么初始值最多只能包含一个值,该值即使转换的话其所占空间也不应大于目标类型的空间
int k = {3.14};  //错误

无论左侧运算对象类型是什么,初始值列表都可以为空,此时编译器创建一个值初始化的临时量并将其赋给左侧运算对象

赋值运算符满足右结合律; in ival, jval; ival = jval = 0;

