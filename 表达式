一元运算符 二元运算符 三元运算符 函数调用也是一种特殊的运算符，它对运算对象的数量没有限制
对于含有多个运算符的复杂表达式来说,要想理解它的含义首先要理解运算符的优先级,结合律,以及运算对象的求值顺序
一般的二元运算符要求两个运算对象相同,运算对象转换
重载运算符运算对象的类型和返回值的类型由运算符定义,但运算对象的个数,运算符的优先级和结合律无法改变
当一个对象被用作右值的时候,用的是对象的值(内容),当对象被用作左值的时候,用的是对象的身份(在内存中的位置)
假设p的类型是int*,因为解引用运算符生成左值,所以decltype(*p)的结果是int&,另一方面,因为取地址运算符生成右值,所有decltype(&p)的结果是int**
f()+g()*h()+j(),对于这些函数的调用顺序没有明确规定,如果f,g,h,j是无关函数，它们既不会改变同一对象的状态也不执行IO任务,那么函数的调用顺序不受限制
一元负号运算符对运算对象值取负后,返回其提升后的副本:
bool b = true;
bool b2 = -b;      //b2的值为true

%俗称取余或取模运算符,参与取余运算的运算对象必须是整数类型

因为关系运算符的求值结果是布尔值,所以将几个关系运算符连写在一起会产生意想不到的效果: if (i < j < k) 若k大于1则为真
所以应写成:if (i < j && j < k)

if(val)  if(!val) 编译器会将val转换成布尔值
if(val == true) 如果val不是布尔值,这样的比较将失去意义

赋值预算符的结果是它的左侧运算对象,并且是一个左值,结果的类型就是左侧运算对象的类型,如果赋值运算符左右两个运算对象类型不同,则右侧对象将转换成左侧运算对象的类型

如果左侧运算对象是内置类型,那么初始值最多只能包含一个值,该值即使转换的话其所占空间也不应大于目标类型的空间
int k = {3.14};  //错误

无论左侧运算对象类型是什么,初始值列表都可以为空,此时编译器创建一个值初始化的临时量并将其赋给左侧运算对象

赋值运算符满足右结合律; in ival, jval; ival = jval = 0;

递增递减运算符:int i = 0, j; j = ++i; //j = 1, i = 1 前置版本得到递增之后的值  j = i++; // j = 1, i = 2后置版本得到递增之前的值

auto pbeg = v.begin();
while(pbeg != v.end() && *beg >= 0)
    cout << *pbeg++ << endl;   //输出当前值并将pbeg向前移动一个元素

成员访问运算符优先级低于点运算符:*p.size()  //错误
p->size();  //箭头运算符
(*p).size(); //点运算符

条件运算符:cond?expr1:expr2;
string finalgrade = (grade < 60) ? "fail" : "pass";  //只对其中一个表达式求值

条件运算符允许嵌套:
string finalgrade = (grade > 90) ? "high grade" : (grade < 60) ? "fail" : "pass";

位运算符作用于整数类型的对象(如果它的值是小整形):~ << >> & ^ |

sizeof运算符:返回一条表达式或一个类型名字所占的字节数
sizeof运算符满足右结合率,运算符的运算对象有两种形式sizeof (type); sizeof expr; //实际返回表达式结果类型的大小

逗号运算符:含有两个运算对象,按照从左向右的顺序依次求值,首先对左侧的表达式求值,然后将求值结果丢弃掉,逗号运算符真正的结果是右侧表达式的值

算数运算符整型提升

包含常量整数值0或者字面值nullptr能转换成任意指针类型,指向任意非常量的指针能转换成void*,指向任意对象的指针能转换成const void*

强制类型转换:static_cast, dynamic_cast, const_cast, reinterpret_cast


