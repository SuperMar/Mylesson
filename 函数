函数形参调用时才申请,函数执行完毕即销毁,()函数调用,函数返回值,函数名,执行体,函数为了代替较复杂的代码块
C++尽量使用传引用代替传指针操作实参的值,不需改变形参的值时,尽量使用const <T> &
函数内部变量static(静态局部变量)在函数执行完毕仍然保留改变后的值
分离式编译:fact.h fact.cc factMain.cc, 函数声明在fact.h 函数定义在fact.cc, fact.cc包含fact.h, cc factMain.cc fact.cc
函数可以多次声明,不可多次定义
函数执行时,main()将控制权交给函数,main()暂停,执行完毕,控制权回到main()
void fcn(const int i) {}
void fcn(int) {}            //错误,重复定义
C++允许定义若干具有相同名字的函数,前提是不同函数的形参列表有明显的区别
形参初始化等同于变量初始化
把函数不会改变的形参定义成普通引用是一种常见错误,极大限制函数所能接受的实参类型,例:不能把const对象,字面值等需要类型转换的对象传递给普通的引用形参
string::size_type find_char(const string &s, char c, string::size_type &occurs);
string::size_type find_char(string &s, char c, string::size_type &occurs);
find_char("Hello World", 'o', ctr);  //编译错误

数组形参:不允许拷贝数组,所以无法以值传递的方式使用数组参数,使用数组时会转换成指针(也需考虑数组越界)
void print(const int*);
void print(const int[]);
void print(const int[10]);

int i = 0, j[2] = {0, 1};
print(&i);
print(j);          //j转换成int*并指向j[0]

使用标准库规范:
void print(const int *beg, const int *end)
{
    while(beg!=end)
        cout << *beg++ << endl;
}

int j[2] = {0, 1};
print(begin(j), end(j));

显示传递一个表示数组大小的形参:
void print(const int ia[], size_t size)
{
    for(size_t i = 0; i != size; ++i){
        cout << ia[i] << endl;
    }
}
只要传递给函数的size的值不超过数组实际的大小,函数就是安全的
数组形参应该是指向const的指针,只有当函数确实要改变元素值的时候,才能形参定义成指向非常量的指

function(int &arr[10])      //错误:arr声明成了引用的数组
function(int (&arr)[10])    //正确:arr是具有10个整数的整型数组的引用
限制了function的可用性,只能传入大小为10的整型数组

多维数组作为形参:
void print(int (*matrix)[10], int rowSize){}
void print(int matrix[][10], int rowSize){}
matrix为指向含有10个整数的数组的指针

main:处理命令行选项
int main(int argc,char *argv[]){}
int main(int argc,char **argv){}
//argv指向char*
main函数位于可执行文件prog内,可以向程序传递以下选项:
prog -d -o ofile data0
argv[0] = "prog"; argv[1] = "-d"; argv[2] = "-o"; argv[3] = "ofile"; argv[4] = "data0"; argv[5] = 0;
可选的实参从argv[1]开始,argv[0]保存程序的名字,而非用户输入

含有可变形参的函数:
initializer_list形参:和vector一样,是一种模板类型;和vector不一样的是,initializer_list对象中的元素永远是常量值
void error_msg(initializer_list<string> il)
{
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " ";
    cout << endl;
}
if (expected != actual)
    error_msg({"functionX", expected, actual});
else
    error_msg({"functionX", "okay"});

省略符形参:为了便于C++程序访问某些特殊的C代码设置,这些代码使用了名为varargs的C标准库功能
大多数类类型的对象在传递给省略符形参时都无法正确拷贝
省略符形参只能出现在形参列表的最后一个位置:
void foo(parm_list, ...);    //逗号可选
void foo(...);

return语句:
return;
return expression;
返回一个值的方式和初始化一个变量或形参的方式完全一样,返回的值用于初始化调用点的一个临时量,该临时量就是函数调用的结果
不要返回局部变量的引用或指针

